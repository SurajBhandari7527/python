#super important for interview

#four types of joining 
''' for eg; if we have   Student ID     Student Name 
                                1           suraj
                                2           sahil
                                3           kiran
    and 
                            Student ID        Course Enrolled
                                2               datascience
                                3               DSA
                                1               Deep Learning
                                
    we want dataframe to be like 
                            Student ID       Student Name         Course Enrolled
                            1                   Suraj               Deep Learning
                            2                   sahil               datascience
                            3                   kiran               DSA                 '''

#that simply means we will have same two columns on the basis of which we will be joining. this is normal joining

#but there are different types of joining  
""" 1. inner join
    2. left join
    3. full join
    4. right join"""
import numpy as np
import pandas as pd

courses=pd.read_csv("D:\python\Datascience\datasets\courses.csv")
students=pd.read_csv("D:\python\Datascience\datasets\students.csv")
nov=pd.read_csv('D:/python/Datascience/datasets/reg-month1.csv')
dec=pd.read_csv("D:/python/Datascience/datasets/reg-month2.csv")

matches=pd.read_csv("D:\python\Datascience\datasets\matches.csv")
delivery=pd.read_csv("D:\python\Datascience\datasets\deliveries.csv")
combined_regs=(pd.concat([nov,dec],ignore_index=True))
print(combined_regs)
#inner join
students.merge(combined_regs,how='inner',on='student_id')
#but the thing to notice is inside the combined_regs there are student ids which are not in the students. only the common is taken
#while the one which are not common to both they are ignored not taken

print(courses)
print(combined_regs)
#both has the column of course_id common but we can see that numpy and c++ course is not taken by anyone
#so if we do inner join those two will get removed but we want to include them as well. so, we use left join

course_regs=courses.merge(combined_regs,how='left',on='course_id')
print(course_regs)

#right join is just the same (it will include the datas of right one dataframe) even if the data of common column is not present in the left one
 
 #outer join
 #this is basically the combination of left join and right join it will include all the datas of right and left dataframe of the common column no matter if something is missing on the left or right dataframe
  

#how to find the total revenue generated by campusx from these all courses?
course_regs=courses.merge(combined_regs,how='inner',on='course_id')
print(course_regs)

print(combined_regs['student_id'].nunique())   
print(course_regs['student_id'].nunique())

print("The total revenue is",course_regs['price'].sum())


#find month by month revenue
nov['Month']='nov'
dec['Month']='dec'

pd.concat([nov,dec],ignore_index=True)
combined_regs=(pd.concat([nov,dec],ignore_index=True))
print(combined_regs)
price_regs=courses.merge(combined_regs,how='inner',on='course_id')
monthwise=price_regs.groupby('Month')
print(monthwise['price'].sum())

# Print the registration table
name_id=students.merge(combined_regs,on='student_id')
print(name_id)
registration_table=name_id.merge(courses,on='course_id')
print(registration_table)
#Plot bar chart for revenue/course
course_group=registration_table.groupby('course_name')
earned_by_courses=course_group['price'].sum()
print(earned_by_courses)
print(earned_by_courses.plot(kind='bar'))

#Find students who enrolled in both the months
group_based_on_names=registration_table.groupby('name')

# print(group_based_on_names['student_id'][(group_based_on_names['Month']) & (group_based_on_names['Month']=='dec')])
# for group,data in registration_table['Month']:
print(group_based_on_names['Month'].unique().count()==2)


#)Find course that got no enrollment
no_enrollment=courses.merge(combined_regs,how='left',on='course_id')
print(no_enrollment[no_enrollment['student_id'].isnull()])

#find students who did no enroll into any courses
student_who_didnt_enrolled=combined_regs.merge(students,how='right',on='student_id')
print(student_who_didnt_enrolled[student_who_didnt_enrolled['course_id'].isnull()])

#Print student name -> partner for all enrolled students

enrolled_students=combined_regs.merge(students,how='left',on='student_id')
print(enrolled_students)
new_enrolled_with_nameofpartner=enrolled_students.merge(enrolled_students,how='inner',left_on='partner',right_on='student_id')
print(new_enrolled_with_nameofpartner)
print(new_enrolled_with_nameofpartner[['name_x','name_y']].drop_duplicates().dropna())

#Find top 3 students who did most number enrollments
group_based_on_names=registration_table.groupby('name')
print(group_based_on_names['student_id'].count().sort_values(ascending=False).head(3))


#find top 3 students who spent the most money for enrollment:
print(registration_table.groupby(['student_id','name'])['price'].sum().sort_values(ascending=False).head(3))

#alternate syntax for merge
pd.merge(students,combined_regs,how='inner',on='student_id')

#op ipl questions
#top 3 stadiums with highest sixes/match ratio
print(delivery.columns)
print(delivery['dismissal_kind'])
print(matches.columns)
print(matches['venue'])
print(delivery.head())
print(delivery['match_id'])
print(matches['id'])

only_sixes=delivery[delivery['batsman_runs']==6]
print(only_sixes)
only_six_group=only_sixes.groupby(['match_id'])
only_six_sum_dataframe=only_six_group['batsman_runs'].sum()
print('no of sixes in each match: ',only_six_sum_dataframe)
combined=matches.merge(only_six_sum_dataframe,how='left',left_on='id',right_on='match_id')
print(combined)
print(combined[combined['batsman_runs'].isnull()]) #this proves there is some value in all rows atleast so mean will not get affected
stadium_group=combined.groupby('venue')

print((stadium_group['batsman_runs'].sum()/(6*stadium_group['batsman_runs'].count())).sort_values(ascending=False).head(3))


#find orange cap holder of all the seasons along with their runs
highest_scorer=delivery.groupby(['match_id','batsman'])
batsman_score=highest_scorer['batsman_runs'].sum()

print(batsman_score)

combine_batsmanscore_matches=matches.merge(batsman_score,how='left',left_on='id',right_on='match_id')
print(combine_batsmanscore_matches)
print(combine_batsmanscore_matches.columns)
season_champion_group=combine_batsmanscore_matches.groupby(['season','batsman'])
season_champion=season_champion_group['batsman_runs'].sum().sort_values(ascending=False)
print(list(season_champion.reset_index()['season']))


